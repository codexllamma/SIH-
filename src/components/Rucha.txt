import React, { useEffect, useRef, useState } from "react";
import { Stage, Layer, Line, Circle, Rect, Text } from "react-konva";



/* ---------------------- Helper: track math ---------------------- */
// compute segments + total length for a polyline points array
function computeSegments(points) {
  const segments = [];
  let total = 0;
  for (let i = 0; i < points.length - 2; i += 2) {
    const x1 = points[i],
      y1 = points[i + 1],
      x2 = points[i + 2],
      y2 = points[i + 3];
    const dx = x2 - x1,
      dy = y2 - y1;
    const length = Math.hypot(dx, dy);
    segments.push({ x1, y1, x2, y2, length });
    total += length;
  }
  return { segments, total };
}

// get position+angle on polyline (points) given progress 0..1
function getPosOnPoints(points, progress) {
  const { segments, total } = computeSegments(points);
  let dist = Math.max(0, Math.min(progress, 0.999999)) * total;
  for (let seg of segments) {
    if (dist <= seg.length) {
      const ratio = seg.length === 0 ? 0 : dist / seg.length;
      const x = seg.x1 + (seg.x2 - seg.x1) * ratio;
      const y = seg.y1 + (seg.y2 - seg.y1) * ratio;
      const angle = Math.atan2(seg.y2 - seg.y1, seg.x2 - seg.x1) * (180 / Math.PI);
      return { x, y, angle };
    }
    dist -= seg.length;
  }
  // fallback to last point
  const last = segments[segments.length - 1];
  return { x: last.x2, y: last.y2, angle: Math.atan2(last.y2 - last.y1, last.x2 - last.x1) * (180 / Math.PI) };
}

/* -------------------------- Data setup -------------------------- */
const tracksData = [
  // left-to-right top line
  { id: "T1", points: [40, 80, 220, 80, 400, 80, 640, 80] },
  // middle bent line
  { id: "T2", points: [40, 160, 200, 160, 360, 180, 540, 220, 680, 220] },
  // bottom line
  { id: "T3", points: [40, 260, 220, 260, 420, 260, 640, 260] },
  // some slanted branch on right
  { id: "T4", points: [420, 80, 520, 120, 620, 160] }
];

// junctions (only these have signals). connectedTracks lists IDs of tracks meeting here
const junctions = [
  { id: "J1", x: 220, y: 80, connectedTracks: ["T1", "T2"] },
  { id: "J2", x: 400, y: 80, connectedTracks: ["T1", "T4"] },
  { id: "J3", x: 360, y: 180, connectedTracks: ["T2", "T4"] },
  { id: "J4", x: 220, y: 260, connectedTracks: ["T2", "T3"] },
  { id: "J5", x: 420, y: 260, connectedTracks: ["T3", "T4"] } // optional overlap
];

// trains: each train is bound to a track (by trackId) and has a progress (0..1) and speed (fraction per second)
const initialTrains = [
  { id: "A", trackId: "T1", progress: 0.05, speed: 0.08, color: "#00bfff" },
  { id: "B", trackId: "T2", progress: 0.2, speed: 0.05, color: "#ff7f50" },
  { id: "C", trackId: "T3", progress: 0.5, speed: 0.06, color: "#ad8cf7" },
  { id: "D", trackId: "T4", progress: 0.15, speed: 0.07, color: "#ffd24d" }
];

/* -------------------------- Component --------------------------- */

export default function App() {
  // compute and cache track lengths to avoid recomputing every frame
  const trackMap = useRef(new Map());
  useEffect(() => {
    for (let t of tracksData) {
      trackMap.current.set(t.id, computeSegments(t.points));
    }
  }, []);

  const [trains, setTrains] = useState(initialTrains);

  // signals state: for each junction id we keep boolean occupied (true => red)
  const [signals, setSignals] = useState(() =>
    junctions.reduce((acc, j) => {
      acc[j.id] = false;
      return acc;
    }, {})
  );

  // helper: get track by id
  const getTrack = (id) => tracksData.find((t) => t.id === id);

  // Helper: compute train's world position and angle given its track and progress
  function trainWorldPos(train) {
    const track = getTrack(train.trackId);
    if (!track) return null;
    return getPosOnPoints(track.points, train.progress);
  }

  // main loop - requestAnimationFrame style using timestamp diffs so speed is consistent
  const lastRef = useRef(performance.now());
  useEffect(() => {
    let rafId = 0;

    function step(now) {
      const dt = (now - lastRef.current) / 1000; // seconds
      lastRef.current = now;

      // First: determine which junctions are currently occupied (train physically within occupyRadius)
      const occupyRadius = 18; // px - if a train is within this many px of junction center, count it as occupying
      const newSignals = { ...signals }; // start from previous, we'll set true/false
      for (let j of junctions) newSignals[j.id] = false;

      // compute positions of trains
      const positions = trains.map((t) => ({ id: t.id, pos: trainWorldPos(t), trackId: t.trackId }));

      // mark junctions occupied if any train is close enough
      for (let j of junctions) {
        for (let p of positions) {
          if (!p.pos) continue;
          const d = Math.hypot(p.pos.x - j.x, p.pos.y - j.y);
          if (d <= occupyRadius) {
            newSignals[j.id] = true;
            break;
          }
        }
      }

      // Second: update trains' progress considering signals & stops
      const stopDistance = 38; // px: how far before junction to begin stopping (braking distance)
      const updatedTrains = trains.map((t) => {
        const track = getTrack(t.trackId);
        if (!track) return t;
        const pos = getPosOnPoints(track.points, t.progress);

        // find the nearest upcoming junctions along the train direction that concern this track
        // we'll check all junctions that include this track
        let shouldStop = false;
        for (let j of junctions) {
          if (!j.connectedTracks.includes(t.trackId)) continue;
          // compute distance from train to junction
          const d = Math.hypot(pos.x - j.x, pos.y - j.y);
          // if that junction is occupied and train is approaching (d < some threshold), stop
          if (newSignals[j.id]) {
            // determine whether train is "upstream" of junction (simple check: progress should be less than 0.98)
            // we will use d < stopDistance to request train to stop before junction
            if (d < stopDistance + 2) {
              shouldStop = true;
              break;
            }
          }
        }

        // if shouldStop, do not advance progress
        if (shouldStop) {
          return { ...t }; // unchanged progress -> stopped
        }

        // Otherwise advance progress by speed * dt (speed is fraction per second)
        let newProgress = t.progress + t.speed * dt;
        if (newProgress >= 1) {
          // loop: wrap to 0 (start) keeping extra
          newProgress = newProgress % 1;
        }
        return { ...t, progress: newProgress };
      });

      setSignals(newSignals);
      setTrains(updatedTrains);

      rafId = requestAnimationFrame(step);
    }

    rafId = requestAnimationFrame(step);
    return () => cancelAnimationFrame(rafId);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [trains]); // we intentionally include trains as dependency because step reads trains; alternative would be refs

  /* ---------------------------- Render ---------------------------- */
  return (
    <div style={{ background: "#111", minHeight: "100vh", padding: 12 }}>
      <h2 style={{ color: "#fff", textAlign: "center", margin: 8 }}>
        Mini Control Room — Network with Junction Signals
      </h2>

      <div style={{ display: "flex", justifyContent: "center" }}>
        <Stage width={760} height={360} style={{ background: "#f8fbfd", borderRadius: 6 }}>
          <Layer>
            {/* Draw tracks */}
            {tracksData.map((t) => (
              <Line key={t.id} points={t.points} stroke="#cfcfcf" strokeWidth={6} lineCap="round" />
            ))}

            {/* Draw junction signals (circles) */}
            {junctions.map((j) => (
              <React.Fragment key={j.id}>
                <Circle x={j.x} y={j.y} radius={10} fill={signals[j.id] ? "#d33" : "#2eb82e"} stroke="#333" strokeWidth={1} />
                <Text text={j.id} x={j.x + 12} y={j.y - 8} fontSize={12} fill="#222" />
              </React.Fragment>
            ))}

            {/* Draw trains */}
            {trains.map((t) => {
              const track = getTrack(t.trackId);
              if (!track) return null;
              const pos = getPosOnPoints(track.points, t.progress);
              const angle = pos.angle || 0;
              return (
                <React.Fragment key={t.id}>
                  <Rect
                    x={pos.x}
                    y={pos.y}
                    width={30}
                    height={14}
                    fill={t.color}
                    offsetX={15}
                    offsetY={7}
                    rotation={angle}
                    cornerRadius={3}
                    shadowBlur={2}
                  />
                  <Text text={t.id} x={pos.x - 6} y={pos.y - 28} fontSize={12} fill="#222" />
                </React.Fragment>
              );
            })}
          </Layer>
        </Stage>
      </div>

      <div style={{ color: "#ddd", textAlign: "center", marginTop: 12 }}>
        <small>
          Trains stop before red junctions. Speeds vary per train. Signals only at junctions — not along every track.
        </small>
      </div>
    </div>
  );
}